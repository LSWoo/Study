# 문자
- 저장된 데이터의 값은 같지만 어떻게 읽느냐에 따라서 값이 달라진다.  
- 예를들어 0x11 은 10진수로 읽으면 17 이라는 값이 나오는것과 같지만, 문자는 0x48 을 아스키코드로 읽으면 H 라는 문자값이 나온다.
- 마지막에는 0x0 (Null) 값을 넣어 문자열이 끝났다는것을 알려줘야한다.

```Assembly
PRINT_STRING msg

두가지의 방법 모두 결과값으로 HelloWolrd 가 출력된다.
section.data
msg db 'HelloWorld',0x0
msg db 0x48,0x65,0x6c,0x6c,0x6f,0x57,0x6f,0x72,0x6c,0x64,0x0
; 같은 데이터라도 아스키코드로 읽으면 HelloWorld 가 되지만 Hex 로 읽으면 의미없는 숫자가 된다.
```
# 엔디안
온라인 게임에서는 데이터를 서버에 전송을 할대 엔디안 이슈가 문제가 될수있다.  
어떤 컴퓨터는 리틀엔디안으로 저장을 하고 서버는 빅엔디안으로 저장을 하면 데이터 순서가 안맞기때문에 서로 완전히 다른 데이터를 분석할수도있다.  
서버에서 나중에 네트워크상으로 데이터를 보낼때 둘중 하나로 고정을 시켜서 보내게된다.  
## 빅 엔디안
**장점**
-

```Assembly
메모리에 0x12345678 을 대입하면 정상적으로 대입이 된다.
메모리 주소값 0x100  0x101  0x102  0x103
변수 값       0x12   0x34   0x56    0x78
```

## 리틀 엔디안
**장점**
- 캐스팅에 유리하다. (데이터 사이즈가 크게 잡혀있는것에서 줄여서 작은 데이터로 변환하는 작업)\

```Assembly
메모리에 0x12345678 을 대입하면 거꾸로 대입이 된다.
메모리 주소값 0x100  0x101  0x102  0x103
변수 값       0x78   0x56   0x34    0x12
```
