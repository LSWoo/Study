## 다형성
### 오버로딩 : 함수를 중복 정의(함수의 이름을 재사용)
```C++
class Player
{
  public:
      Move(){ cout << "Move Player" << endl; }
      Move(int a){ cout << "Move Player int Version" << endl; }
      Move(int a, float b){ cout << "Move Player int, float Version" << endl; }
  public:
      int _hp;
}
```

### 오버라이드 : 함수를 재정의(부모 클래스의 함수를 자식 클래스에서 재정의)
```C++
class Player
{
  public:
      Move(){ cout << "Move Player" << endl; }
      Move(int a){ cout << "Move Player int Version" << endl; }
      Move(int a, float b){ cout << "Move Player int, float Version" << endl; }
  public:
      int _hp;
}

class Knight : public Player
{
  public:
      Move(){ cout << "Move Knight" << endl; }
  public:
      int _stamina;
}

class Mage : public Player
{
  public:
      Move(){ cout << "Move Mage" << endl; }
  public:
      int _mp;
}
```
## 바인딩
- 정적 바인딩(Static Binding) : 컴파일 시점에 결정
- ★동적 바인딩(Dynamic Binding) : 실행 시점에 결정
```Text
일반 함수는 정적 바인딩을 기본적으로 사용한다.
동적 바인딩을 사용하고 싶다면 가상 함수(virtual function) 를 사용한다.

자식 클래스에서 가상 함수를 재정의 하게되면 virtual 을 붙이지 않아도 붙인것과 똑같이 동작하게된다.
그런데 실제 객체가 어떤 타입인지 어떻게 알고 가상 함수를 호출하는것일까.
가상 함수 테이블이라는것이 만들어지는데 
```

### 가상 함수를 사용하여 동적 바인딩
```C++
class Player
{
  Player()
  {
      _hp = 100;
  }
  
  public:
      Move(){ cout << "Move Player" << endl; }
      virtual void VMove() { cout << "Move Player" << endl; }
      
  public:
      int _hp;
}

class Knight : public Player
{
  Kinght()
  {
      _stamina = 100;
  }

  public:
      Move(){ cout << "Move Knight" << endl; }
      void VMove() { cout << "Move Knight" << endl; } // 가상 함수를 재정의 하게되면 virtual 을 붙이지 않아도 붙인것과 똑같이 동작하게된다.
      
  public:
      int _stamina;
}

void MovePlayer(Player* player)
{
   player->Move();
}

int Main()
{
  Player p;
  
  Knight k;
  
  MovePlayer(&k)
}
```
