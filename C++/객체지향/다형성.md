## 다형성
### 오버로딩 : 함수를 중복 정의(함수의 이름을 재사용)
```C++
class Player
{
  public:
      Move(){ cout << "Move Player" << endl; }
      Move(int a){ cout << "Move Player int Version" << endl; }
      Move(int a, float b){ cout << "Move Player int, float Version" << endl; }
  public:
      int _hp;
}
```

### 오버라이드 : 함수를 재정의(부모 클래스의 함수를 자식 클래스에서 재정의)
```C++
class Player
{
  public:
      Move(){ cout << "Move Player" << endl; }
      Move(int a){ cout << "Move Player int Version" << endl; }
      Move(int a, float b){ cout << "Move Player int, float Version" << endl; }
  public:
      int _hp;
}

class Knight : public Player
{
  public:
      Move(){ cout << "Move Knight" << endl; }
  public:
      int _stamina;
}

class Mage : public Player
{
  public:
      Move(){ cout << "Move Mage" << endl; }
  public:
      int _mp;
}
```
## 바인딩
- 정적 바인딩(Static Binding) : 컴파일 시점에 결정
- ★동적 바인딩(Dynamic Binding) : 실행 시점에 결정
```Text
일반 함수는 정적 바인딩을 기본적으로 사용한다.
동적 바인딩을 사용하고 싶다면 가상 함수(virtual function) 를 사용한다.
```

### 가상 함수를 사용하여 동적 바인딩
```C++
class Player
{
  public:
      Move(){ cout << "Move Player" << endl; }
      virtual void VMove() { cout << "Move Player" << endl; }
  public:
      int _hp;
}

class Knight : public Player
{
  public:
      Move(){ cout << "Move Knight" << endl; }
      void VMove() { cout << "Move Knight" << endl; } // 가상 함수를 재정의 하게되면 virtual 을 붙이지 않아도 붙인것과 똑같이 동작하게된다.
  public:
      int _stamina;
}

void MovePlayer(Player* player)
{
   player->Move();
}

int Main()
{
  Player p;
  
  Knight k;
  
  MovePlayer(&k)
}
```
